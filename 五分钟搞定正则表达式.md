# 五分钟搞定正则表达式



### 文章概览

![re](https://user-gold-cdn.xitu.io/2019/10/20/16de9970248b074e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 一、正则表达式介绍

> 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。

不用过多介绍，大家对正则表达式应该不太陌生。即使没有用过，也一定听说过。
我们先看几个常见的正则表达式：

```
匹配 IP 地址
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)

匹配电子邮箱
([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})
复制代码
```

对于正则表达式，第一映像是一串神秘的字符串。如果不是真正了解其规则，看到这字符串，定然是摸不着头脑。

不过说实话，了解其规则以后，看到这数字，也有点头疼。毕竟正则这个东西，写时爽歪歪，看时如天书。

话虽这样说，正则表达式说白了，也就是一连串的规则而已，只要了解了规则，一点一点总能看懂。所以不要有畏难情绪。

我们从最简单的例子开始，一点一点添加规则，争取让大家在学会正则表达式的过程中感觉不到丝毫痛苦。
（这里有一个网站，[tool.oschina.net/regex/#，可以在…](http://tool.oschina.net/regex/#%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%EF%BC%8C%E8%AF%BB%E8%80%85%E6%9C%8B%E5%8F%8B%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E4%B8%8A%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%A7%A3%EF%BC%8C%E4%B9%9F%E7%94%A8%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%EF%BC%89%E3%80%82)

### 二、几个常用规则

前面看了那么复杂的例子，我们这里回归本源，从一个简单的例子开始看。

#### 2.1 完全匹配

正则表达式是用来匹配文本的，现在假设我们要匹配 "abcdefg" 这一字符串中的 "abc" 三个字母，我们该怎么写呢？

```
abc
复制代码
```

对，不要怀疑，就是这么简单。

如果想匹配 "def"，那么就是

```
def
复制代码
```

是不是很简单呢？是不是小脑瓜中又透露出一丝疑惑？

如果正则表达式的匹配内容很简单，也很明确，可以进行完全匹配，写出来的结果就是这样的。

#### 2.2 符号 |

那我们再继续往后看。

还是 "abcdefg" 字符串，我们想匹配其中的 "ab" 和 "ef" 两个子串，怎么写呢？按照上面的写法，就是写两个正则 "ab" 和 "ef" 来匹配。这样可以，不过略显麻烦。我们写法如下：

```
ab|ef
复制代码
```

这里我们新加了 `"|"` 这个字符，表示 或，即匹配 ab 或者 ef，是不是就方便了许多。

再继续看，这次我们需要改变一下待匹配的字符串。

我们在 "acabcdefgh acbbcdefgh accbcdefgh" 字符串中，要匹配 "abcdef"，"bbcdef"，"cbcdef" 三个子串。

读者朋友们一看，这题非常简单，用上面的方法，正则表达式如下：

```
abcdef|bbcdef|cbcdef
复制代码
```

写法正确，不过略显繁琐。我们的写法如下：

```
(a|b|c)bcdef
复制代码
```

是不是有些理解 "|" 的使用了呢。

那我们要匹配 "acabcdef"，"acbbcdef"，"accbcdef" 这三个子串怎么写呢？

```
ac(a|b|c)bcdef
复制代码
```

这下子理解 "|" 的使用了吧。而且我们现在的的写法，是不是长得有些 ”像“ 正则表达式了呢？

#### 2.3 符号 []

我们继续。
上面的例子，我们如果不用 "|"，可以实现么？

答案是可以的，写法如下：

```
ac[abc]bcdef
复制代码
```

是不是看着比上面更清爽一点呢？

我们这里引入了一个新的字符 `"[]"`。

这对中括号是字符集的意思，里面包含的字符，都是或（"|"）的关系。

我们还可以这样写：

```
ac[a-c]bcdef
复制代码
```

"[a-c]" 表示的是匹配 a-c 之间的任意字符。

这里对 "[]" 稍微多说一些，[] 除了可以放字符集合以及字符范围以外，还可以做取反操作。

比如 "[^a-c]" 表示的是匹配 a-c 范围以外其他的字符。"[^0-8]" 表示的是匹配 0-8 范围以外的其他字符。

到了这里，我们已经可以写一些简单的匹配规则了。

#### 2.4 限制符号 * + ? {}

我们继续往下看。

我们现在想匹配 类似 "fooooooooooooooooof" 这样子的字符串，中间的 "o" 个数我们不能确定，上面讲到的规则就有点无能为力了。

那我们该怎么写呢？

```
fo*f
复制代码
```

这里的 `"*"` 表示匹配前面的子表达式零次或多次。

那么有些读者朋友会问了，如果想匹配至少有一个 "o" 该怎么写呢？

```
fo+f
复制代码
```

这里的 `"+"` 表示匹配前面的子表达式一次或多次。

那么读者朋友又问了，如果想匹配 0 个或者者 1 个 该怎么写呢？

```
fo?f
复制代码
```

这里的 `"?"` 表示匹配前面的子表达式零次或一次。

那么有些读者朋友又会问了，如果想匹配确定次数的 "o" 该怎么写呢？

我们可以这样写：

```
fo{2}f
复制代码
```

上面的规则，会匹配 foof，即匹配 2 个 "o"。

所以，`"{n}"` 表示匹配前面子表达式 n 次。

那读者朋友们再次发问，如果想匹配至少 n 个 "o" 该怎么写呢？

```
fo{2,}f
复制代码
```

`"{n,}"` 表示匹配前面子表达式至少 n 次。

那读者朋友们这次不发问了，会举一反三了，那如果想匹配 最少 n 个，最多 m 个呢？

```
fo{2,5}f
复制代码
```

`"{n,m}"` 表示匹配前面子表达式至少 n 次，至多 m 次。

所以 "*" 等价于 "{0,}"，"+" 等价于 "{1,}"，"?" 等价于 "{0,1}"。

到这里，我们能写的匹配规则更多了，而且可以说大部分匹配运用上面的规则都可以实现了。

大家可以回头看看文章开头贴的几段正则表达式，看看是否能看懂了。

当然除此之外，正则里的规则其实还是不少的，除了上面几个，我们再看几个比较常用的。

#### 2.5 几个转义字符

在正则表达式里，也有一些转义字符，表示一些特殊的含义。

`"\d"` 表示匹配数字字符，等价于 "[0-9]"。

`"\D"` 表示匹配非数字字符，等价于 "[^0-9]"。

`"\n"` 表示匹配换行符。

`"\s"` 表示匹配任何空白字符，等价于 "[\f\n\r\t\v]"。

`"\S"` 表示匹配任何非空白字符，等价于 "[^\f\n\r\t\v]"。

#### 2.6 符号 .

符号 `"."` 会匹配 "\n" 以外的所有字符，也是比较常用的。

#### 2.7 符号 ?

到目前为止，我们已经学习了大部分常用的正则表达式规则，日常开发基本已经够用了。

不过使用正则表达式时，限制字符 "* + ? {}" 默认的匹配规则是贪婪的。什么意思呢？

比如说有一个字符串 "abbbbb"，我们使用正则表达式 "ab+" 去匹配，匹配的结果是 "abbbbbbb"，会尽可能多的去匹配满足的字符。

我们如果想尽可能少的匹配满足的字符，那么就在限定符后面加 "?"。

"ab+?" 匹配的结果就是 ab。

`"?"` 符号的非贪婪匹配，在某些情况下也是很有用的。

#### 2.8 符号 ()

最后我们再来看一个符号 "()"，小括号的含义是分组，可以理解为被小括号包含的子表达式就是一个分组，在前面介绍 "|" 的时候我们使用过。

不过分组也分很多类型。

`"(pattern)"` 小括号单纯的包含了子表达式，表示此分组可以被捕获。捕获的意思就是此分组的内容会被保存下来，后续可以从匹配的集合中获取到。

`"(?:pattern)"` 小括号中增加了 ?: 前缀，表示此分组不可以被捕获。后续匹配的集合中就不会包含此分组信息。
这样说下来，不太好理解。这里需要结合具体开发语言的实现来说。先留个悬念，后面会讲到。

`"(?=pattern)"` 小括号中增加了 ?= 前缀，表示的是匹配此分组，但是此分组里的内容不需要被获取。

`"(?!pattern)"` 小括号中增加了 ?! 前缀，表示的是匹配此分组之外的内容，但是此分组里的内容不需要被获取。

举个栗子：
正则表达式 "Windows(?=95|98|NT|2000)" 可以匹配字符串 "Windows2000" 中的 "Windows"，但是不能匹配 "Windows3.1" 中的 Windowds。

正则表达式 "Windows(?!95|98|NT|2000)" 可以匹配字符串 "Windows3.1" 中的 "Windows"，但是不能匹配 "Windows2000" 中的 Windowds。

以上就是正则表达式里一些常见的规则解析。

#### 2.9 看看文章开头的例子

我们在文章开头放了两个例子，这里来分析一下。

**匹配 IP 地址的正则表达式**：
"((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)"

我们分段来看。

先看第一段 `"(2[0-4]\d|25[0-5]|[01]?\d\d?)\.)"`，这里用 "|" 分割了三种匹配情况。

第一种是 `"2[0-4]\d"`，即三位数字，第一位是 2，第二位是 0 - 4 之间，第三位是任意数字。

第二种是 `"25[0-5]"`，三位数字，第一位是 2，第二位是 5，第三位是 0 - 5 之间。

第三种是 `"[01]?\d\d?"`，第一位是 0 或者 1，匹配零次或一次，第二位和第三位是任意数字，第三位数字匹配零次或一次，也就是 一位数，两位数，三位数都可能满足这种情况。

第一段末尾是 `"\."` 作为分隔符。

再来看第二段 `"{3}"`，这个表示前面的子表达式重复三次，也就是 IP 地址的前三个字节。

再看第三段 "(2[0-4]\d|25[0-5]|[01]?\d\d?)"，和第一段是一样的。

**匹配电子邮箱**：
"([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})"

也是分段来看。

第一段 `"([a-z0-9_\.-]+)"`，表示匹配 a-z 范围内的字母，0-9 范围的数字，以及 "_"，"."，"-" 三个字符，"+" 表示至少有一个字符。

第二段 `"@"` 表示匹配 "@" 字符。

第三段 `"([\da-z\.-]+)"`，"\d" 表示匹配任意数字，a-z 范围的字母，"."，"-" 两个字符，"+" 至少有一个字符。

第四段 `"\."` 表示匹配 "." 字符。

第五段 `"([a-z\.]{2,6})"`，表示匹配 a-z 范围的字母，"." 字符，"{2,6}" 表示至少 2 个字符，至多 6 个字符。

经过上面的讲解，大家应该对正则表达式有了进一步的了解。

### 三、在代码中如何使用

在了解了正则表达式的规则以后，我们看一下在实际代码中是如何使用的。

这里以 Java 代码作为示例。

在 Java 中，关于正则表达式的主要有两个类，[Pattern](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html) 和 [Matcher](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html)。

我们看一下具体如何使用。

```
package com.zy.java;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ReTest {
    public static void main(String[] args) {
        String str = "grilboy1girlboy2boy3girl";
        String pattern = "boy([0-9])";

        // 创建 Pattern 对象
        Pattern r = Pattern.compile(pattern);
        // 创建 matcher 对象
        Matcher m = r.matcher(str);
        while (m.find()) {
            System.out.println("match boy: " + m.group(0));
            System.out.println("match boy number: " + m.group(1));
        }

        String phoneNumber = "18888888888";
        String phonePattern = "^[1](([3][0-9])|([4][5-9])|([5][0-3,5-9])|([6][5,6])|([7][0-8])|([8][0-9])|([9][1,8,9]))[0-9]{8}$";
        r = Pattern.compile(phonePattern);
        m = r.matcher(phoneNumber);
        System.out.println("is phone number: " + m.matches());

        r = Pattern.compile(pattern);
        String[] res = r.split(str);
        for (String s : res) {
            System.out.println("split res: " + s);
        }
    }
}
复制代码
```

上面代码运行的结果如下：

```
match boy: boy1
match boy number: 1
match boy: boy2
match boy number: 2
match boy: boy3
match boynumber: 3
is phone number: true
split res: gril
split res: girl
split res: 
split res: girl

Process finished with exit code 0
复制代码
```

在 Java 中使用正则表达式分三步走：

1. 写好正则表达式
2. Pattern.compile 生成 Pattern 对象
3. 调用 Pattern 相关的正则操作

`Pattern` 类中有几个方法会比较常用：

`Pattern#matcher` 生成 Matcher，可以对正则表达式进行匹配，以及获取匹配的内容。

`Pattern#split` 根据正则表达式内容划分字符串。

`Matcher` 类中也有几个方法比较常用：

`Matcher#find` 寻找下一个满足规则的子串，通常用在查找子串中。

`Matcher#matches` 用来判断整个字符串是否满足匹配规则，常用的类似匹配电话号码，邮箱等等。

`Matcher#group` 就是获取我们在上面讲到的 "()" 小括号分组。默认 group(0) 整个串的匹配，group(1)，group(2) 等等往后顺延，就是小括号内的分组。

在我们上面的例子中的正则表达式是 "boy([0-9])"，用来获取字符串中的 boy，而括号中的分组是 boy 的编号，在生成 Matcher 以后，调用 Matcher#group(0) 获取的是整个匹配内容，Matcher#group(1) 获取的是小括号分组的内容。

通过上面例子，大家应该明白 "()" 的作用了吧。

### 四、规则全集

下面总结一下正则表达式的所有规则，在使用时可以查阅，引用自 [tool.oschina.net/uploads/api…](https://tool.oschina.net/uploads/apidocs/jquery/regexp.html%EF%BC%9A)

| 字符         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| \            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。 |
| ^            | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 |
| $            | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 |
| *            | 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 |
| +            | 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 |
| ?            | 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 |
| {n}          | n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 |
| {n,}         | n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 |
| {n,m}        | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 |
| ?            | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 |
| .            | 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(. |
| (pattern)    | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 |
| (?:pattern)  | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“( |
| (?=pattern)  | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95 |
| (?!pattern)  | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95 |
| (?<=pattern) | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?<=95 |
| (?<!pattern) | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?<!95  |
| x\|y         | 匹配x或y。例如，“z                                           |
| [xyz]        | 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 |
| [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 |
| [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 |
| [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 |
| \b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 |
| \B           | 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 |
| \cx          | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 |
| \d           | 匹配一个数字字符。等价于[0-9]。                              |
| \D           | 匹配一个非数字字符。等价于[^0-9]。                           |
| \f           | 匹配一个换页符。等价于\x0c和\cL。                            |
| \n           | 匹配一个换行符。等价于\x0a和\cJ。                            |
| \r           | 匹配一个回车符。等价于\x0d和\cM。                            |
| \s           | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
| \S           | 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。                   |
| \t           | 匹配一个制表符。等价于\x09和\cI。                            |
| \v           | 匹配一个垂直制表符。等价于\x0b和\cK。                        |
| \w           | 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。         |
| \W           | 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。                  |
| \xn          | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&1”。正则表达式中可以使用ASCII编码。. |
| \num         | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 |
| \n           | 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
| \nm          | 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 |
| \nml         | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |
| \un          | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 |

### 总结

最后，大家只要多多练习，实际开发中多使用，掌握正则表达式不是难事～

### 参考资料

[tool.oschina.net/uploads/api…](https://tool.oschina.net/uploads/apidocs/jquery/regexp.html)